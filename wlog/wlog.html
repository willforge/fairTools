<!DOCTYPE html>
<meta charset="utf8"/>
<script src=../js/essential.js></script>
<script src=../js/sha256.js></script>
<script src=../js/ipfs.js></script>
<script src=../js/functions.js></script>
<link rel="stylesheet" href="style.css"/>

<div>
peerid: <span id=peerid></span>
<br>network: <input name=label size=12 onchange="change_token(event)"; value="a big log"> <button id=join onclick="join(event)">join</button>
<br>token: <span id=token></span>
<br>local: <span id=local></span> (mfs version)
<button id=display onclick="display_table(logf)">display</button>
<br>providers <span id=status></span>:
<div id=peerids></div>
<button id=provs onclick="provs(event)">provs</button>

<br><input type=checkbox name=qmonpub> add qm with publish (<i>blockchain</i>)
<br>timestamp: <input name=ts value onmouseover="this.value=Date.now();">
<br>line: <input type=text name=record size=74>
<br><button id=submit>
<select name=op style="margin-right: 1rem;">
<option value=D >remove</option>
<option value=A selected>append</option>
</select><span onclick="submit(event)">submit</span>
</button>

<button id=publish onclick="publish(event)">publish</button>
<button id=update onclick="update(event)">update</button>
<progress id="bar" value="0" max="100">0%</progress><span id="per"></span>
<button id=reduce onclick="reduce(event)">reduce</button>
<br>url: <span id=url></span> (url of new log file on ipfs)
<br>root: <span id=root></span> (published root folder (/.../published/))
<br>prev: <span id=prev></span> (previous version of root folder)
<br>remote: <span id=remote></span> (list of log file providers)
<hr>

<table id=table border=2>
<thead>
<tr><th colspan=6>:label</th></tr>
<tr><th>rank</th><th>stamp</th><th>flag</th><th>text</th><th>owner</th><th>date</th><th>action</th></tr>
</thead>
<tbody id=tbody>
<tr id=row0><td>:idx</td><td>:ts</td><td>:flag</td><td>:text</td><td>:owner</td><td>:date</td><td>:action</td></tr>
</tbody>
</table>
<hr>
<br>wlog:<br><textarea id=file cols=80 rows=25></textarea>
</div>


<script>
var peerid;
const emptyd='QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn';
const qmgen='QmbFMke1KXqnYyBBWxB74N4c5SBnJMVAiMNRcGu6x1AwQH';
const webkey='QmY5irRjuwhhFvkY88ScnM7ow3DxvbhEi13mDAsUUVHRN4';
const key='clef-secrete';
var label=document.getElementsByName('label')[0].value;
let logf;
var token;
var peerids;

main();
async function main() {
   await Promise.resolve(promisedConfig); // just to wait for config !
   peerid = await Promise.resolve(promisedPeerId);
   document.getElementById('peerid').innerHTML = `<a href=${gw_url}/ipns/${peerid}>${peerid}</a>`;
   console.log('main.peerid:',peerid);
   update_token( document.getElementsByName('label')[0].value);
   token = await get_token(nid);
   display_status('pending');
   peerids = await ipfsFindProvs(token);
   display_status('ok');
   display_provs(peerids);
   console.log('main.peerids',peerids);
}

function change_token(ev) {
   label = ev.target.value.replace(/ /g,'-');
   update_token(label);
}

async function update_token(label) {
   let [callee, caller] = functionNameJS(); // logInfo("message !")
   console.debug(callee+'.label:',label);
   let labelp = label.replace(/\s+/g,'-');
   uri=`${key},urn:wwlog:${labelp}.txt`;
   nid= getNid(uri);
   logf = `/public/share/${nid}/${labelp}.txt`;
   document.getElementById('local').innerHTML = `<a target=_blank href=${gw_url}/ipns/${webkey}/#/files${logf}>${logf}</a>`;
   token = await get_token(nid);
   display_status('pending');
   peerids = await ipfsFindProvs(token);
   display_status('ok');
   display_provs(peerids);
   console.log('main.peerids',peerids);


}

async function get_token(str) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  token = await ipfsGetToken(str);
  console.debug(callee+'.token:',token);
  document.getElementById('token').innerHTML = token;
  return token
}


async function join(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let token = await ipfsAddToken(nid);
  console.debug(callee+'.token:',token);
  document.getElementById('token').innerHTML = `<a href=${gw_url}/ipfs/${token}>${token}</a>`;
}

async function display_provs(peerids) {
  let buf = '<ul>';
  for (peer of peerids) {
    buf += `<li><a target=_blank href=${gw_url}/ipns/${peer}/>${peer}</a></li>\n`
  }
  buf += "</ul>\n";
  document.getElementById('peerids').innerHTML = buf;
}

async function display_table(file) {
   let [callee, caller] = functionNameJS(); // logInfo("message !")
   let content = await getMFSFileContent(file);
   let lines = content.split(/\r?\n/).slice(0,-1);
   let user = peerid;
   let records = [];
   for (let line of lines) {
     let matches = line.match(/^# user:(\w+)/);
     if (matches) {
        user = matches[1];
     } else if (line.match(/^\d+ /)) {
       record = mysplit(' ',line,3);
       if (record[1] == 'P') {
         user = record[2].match(/user:(\w+)/)[1];
       } 
       record[3] = user;
       records.push(record);
     }
   } 
   let selected = {};
   for (let record of records.sort(by_time) ) {
      let key = record[2];
      if (record[1] == 'A' || record[1] == 'P' ) {
         selected[key] = record;
      }
      if (record[1] == 'D') {
         delete selected[key];
      }
   }
   console.debug(callee+'.selected:',selected);
   let table = document.getElementById('tbody');
   // save template
   let tmpl = document.getElementById('row0');
   // clear table...
   clear_table();

   for (let key of Object.keys(selected).sort(selected_by_timestamp) ) {

      let [timestamp,op,text,user] = selected[key];
      console.debug(callee+'.text:before',text);
      text = text.replace(user,alias(user));
      console.debug(callee+'.text:after',text);
      let time = getTime(timestamp);
      let date = getDate(timestamp);
      let button = '<button onclick="delete(event)">delete</button>';
      let newrow = table.insertRow(-1); // insert in last position
      // replace parameter's values w/i template :
      // format <tr id=row0><td>:idx</td><td>:ts</td><td>:flag</td><td>:text</td><td>:owner</td><td>:date</td><td>:action</td></tr>
      newrow.innerHTML = tmpl.innerHTML.replace(/:idx/,newrow.rowIndex);
      newrow.innerHTML = newrow.innerHTML.replace(/:ts/,time);
      newrow.innerHTML = newrow.innerHTML.replace(/\:flag/,op);
      newrow.innerHTML = newrow.innerHTML.replace(/\:text/,text);
      newrow.innerHTML = newrow.innerHTML.replace(/\:owner/,alias(user));
      newrow.innerHTML = newrow.innerHTML.replace(/\:date/,date);
      newrow.innerHTML = newrow.innerHTML.replace(/\:action/,button);
      console.debug(callee+'.newrow:',newrow);
   }

    
       /* if (typeof(seen[key]) == 'undefined') { # drops all duplicates
         selected[key] = record;
       } */

   function selected_by_timestamp(a,b) {
     return ((selected[a][0] - selected[b][0]) || compare(a,b));
   }
}

function alias(u) {
  return u.substring(0,2)+'--'+u.substr(-6);
}

function clear_table() {
     let [callee, caller] = functionNameJS();
     let e = document.getElementById('table');
     console.log(callee+'.template row:',e.rows[2]);
     for (i = e.rows.length-1; i > 1; i--) {
           e.deleteRow(i)
     }
     console.log(callee+'.nrow after delete:',e.rows.length)
}

async function display_file(file) {
   let [callee, caller] = functionNameJS(); // logInfo("message !")
   let content = await getMFSFileContent(file);
   let lines = content.split(/\r?\n/).slice(0,-1);
   let filtered = lines.filter( _ => { return _.match(/^[^#]/) });
   let records = filtered.map( _ => { return mysplit(' ',_,3); });

   var selected = {};
   for (record of records.sort(by_time)) {
      console.debug(callee+'.record:',record);
      if (record[1] == 'A' || record[1] == 'P' ) {
         selected[record[2]] = record;
      }
      if (record[1] == 'D') {
         delete selected[record[2]];
      }
   }
   console.debug(callee+'.records.sort(by_time):',records.sort(by_time));
   console.debug(callee+'.selected:',selected);

   function selected_by_timestamp(a,b) {
      return ((selected[a][0] - selected[b][0]) || compare(a,b));
   }
   //  -------------------------------------------------
   // note: P records are deletable !
   let qmprev = emptyd;
   let qmcur = emptyd;
   let sorted_selected_keys = Object.keys(selected).sort(selected_by_timestamp)
   for (record of sorted_selected_keys.map( k => selected[k] )) {
      if ( record[1] == 'P' ) {
         lastpub = record[2];
         let P = lastpub.split(/\s+/,3);
         qmprev = qmcur;
         qmcur = P[2];
         auth = P[0];
         console.debug(callee+'.auth:',auth);
         console.debug(callee+'.qmcur:',qmcur);
         if (auth != `user:${peerid}`) {
            qmprev = qmcur;
         }
         console.debug(callee+'.qmprev:',qmprev);
     }
     if (qmprev != emptyd) {
       document.getElementById('prev').innerHTML = `<a href=${gw_url}/ipfs/${qmprev}${logf}>${qmprev}</a>`;
     }
  
   }
   // -------------------------------------------------

   document.getElementById('file').value = sorted_selected_keys.join("\n");
}


function by_time(a,b) {
  return ((a[0] - b[0]) || compare(a[1],b[1]));
}
function numerically(a,b) {
  return (a.split(' ',1) - b.split(' ',1)) || compare(a,b);
}

function mysplit(sep,str,limit) { // split a la perl !
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let a = str.split(sep);
  let last = a[limit-1];
  for (let i = limit; i < a.length; i++) {
    last += sep + a[i];
  }
  a[limit-1] = last;
  a = a.slice(0,limit); // end position excluded
  // console.debug(callee+'.a:after',a)
  return a
}

async function provs(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  // if (typeof(peerids) == 'undefined') {
    console.debug(callee+'.token:',token);
    display_status('pending');
    peerids = await ipfsFindProvs(token);
    display_status('ok');
  // }
  
}

function chop(s) {
  return s.slice(0,-1);
}

async function reduce(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let seen = {};
  let result = '';
  let content = await getMFSFileContent(logf);
      content = content.replace(/\r\n/g,"\n").slice(0,-1); // remove last \n
  let lines = content.split(/\n/);
  // console.debug(callee+'.lines:',lines);
  for (let line of lines) {
    if (typeof(seen[line]) == 'undefined') {
      result += line+ "\n";
      seen[line]++;
    }
  }
  console.debug(callee+'.result:',[{result}]);
  await mfsRemove(logf);
  await mfsCopy('QmbFMke1KXqnYyBBWxB74N4c5SBnJMVAiMNRcGu6x1AwQH',logf);
  let qmlogf = await ipfsLogAppend(logf,result);
  document.getElementById('url').innerHTML = `<a href="${gw_url}/ipfs/${qmlogf}">/ipfs/${qmlogf}</a>`
  display_file(logf);
  return qmlogf
}

function progress (percent) {
let bar = document.getElementById("bar");
let per = document.getElementById("per");
bar.value = percent;
per.innerHTML = percent + "%";
}

async function update(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  document.getElementById('update').disabled=true
  let qmlogf;
  let buf = '<ul>';
  progress (10)
  for (let peer of peerids) {
    console.log(callee+'.peer:',peer);
    if (peer == peerid) { continue }
    let ipath = await ipfsNameResolve(peer);
    if (typeof(ipath) != 'undefined') {
    console.log(callee+'.ipath:',ipath);
    let qpath = await ipfsResolve(`${ipath}${logf}`);
    if (typeof(qpath) != 'undefined') {
       console.debug(callee+'.qpath:',qpath);
       let log = await ipfsGetContentByHash(qpath);
       console.debug(callee+'.log:',log);
       qmlogf = await ipfsLogAppend(logf,log);
       console.debug(callee+'.qmlogf:',qmlogf);
       buf += `<li><a target=_blank href=${gw_url}${qpath}/>${ipath}${logf}</a></li>\n`;
       document.getElementById('remote').innerHTML = buf + "</ul>";
       display_file(logf);
    }
    }
  }
  buf += "</ul>\n";
  document.getElementById('update').disabled=false;
  document.getElementById('remote').innerHTML = buf;
  console.debug(callee+'.qmlogf:',qmlogf);
progress (100)
  return qmlogf;
}

async function publish(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
   document.getElementById('publish').disabled=true
   let qm = await publish_root();
   let qm_on_publish_flag = document.getElementsByName('qmonpub')[0].checked;
   if (qm_on_publish_flag) {
      display_file(logf);
      let tics = Date.now();
      let date = getDate();
      let time = getTime();
      let record = `${tics} P user:${peerid} published ${qm} on ${date} @ ${time}`;
      let hash = await ipfsLogAppend(logf,record+"\n");
      console.log(callee+'.hash:',hash);
      display_file(logf);
   }

   document.getElementById('root').innerHTML = `<a href="${gw_url}/ipfs/${qm}">${qm}</a> (published)`
      document.getElementById('publish').disabled=false

}

async function submit(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  // let delete_flag = document.getElementsByName('delete')[0].checked ? 'D' : 'A';
  let op_cmd = document.getElementsByName('op')[0].value;
  console.debug(callee+'.op_cmd:',op_cmd);
 
  let timestamp = document.getElementsByName('ts')[0].value;
  let line = document.getElementsByName('record')[0].value;
  let record = `${timestamp} ${op_cmd} ${line}`;
  console.debug(callee+'.line:',line);
  //let buf = await getMFSFileContent(path);
  let date = getDate();
  let time = getTime();
  let header = `# user:${peerid} on ${date} @ ${time}\n`;
  let hash = await ipfsLogAppend(logf,header+record+"\n");
  console.log(callee+'.hash:',hash);
  document.getElementById('url').innerHTML = `<a href=${gw_url}/ipfs/${hash}>${logf}</a>`;
  display_file(logf);
}

function display_status(s) {
  let imgs = { 'pending':'img/spinner.png', 'ok':'img/check-mark.png' };
  document.getElementById('status').innerHTML=`<img alt=${s} src=${imgs[s]} height="24">`;
  if (s.match('pending')) {
     document.getElementById('update').disabled=true
  } else if (s.match('ok')) { 
     document.getElementById('update').disabled=false
  }
}
</script>

