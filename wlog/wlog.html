<!DOCTYPE html>
<meta charset="utf8"/>
<script src=../js/config.js></script>

<script src=../js/essential.js></script>
<script src=../js/sha256.js></script>
<script src=../js/ipfs.js></script>
<script src=../js/functions.js></script>
<link rel="stylesheet" href="style.css"/>

<div class=modal>
<div class=overlay></div>
<div id=popup>
  <p style="text-align:center;"> Your IPFS node seems to be unreachable,
  as your "peerid" has been evaluated to '<span style="color:red;">undefined</span>'.</p>
  <br>There are two possible options :
  <ul>
  <li>If you have not installed IPFS docker [<a href=https://hub.docker.com/r/ipfs/go-ipfs>1</a>],
  please follow the installation instructions in the 
  <a href=INSTALL.html>INSTALL</a> file.

  <li>your docker container might not be loaded, please run the following command in a shell:
  <code> sh wlog-url.sh</code>
  </ul>

  <br><br>
  <button style="float:right" onclick="close_popup(event);">OK</button>
</div>
</div>

<div>
peerid: <span id=peerid>:peerid</span>
<br>network: <input name=label size=12 onchange="change_token(event)"; value="a big log"> <button id=join onclick="join(event)">join</button>
<br>token: <span id=token></span> (network token : identifies wlog)
<br>local: <span id=local></span> (mfs version)
<button id=display onclick="display_table(logf)">display</button>
<br>providers <span id=status></span>:
<div id=peerids></div>
<button id=provs onclick="provs(event)">provs</button>
<hr>
<table id=table border=2>
<thead>
<tr><th colspan=7 id=labelp>:label</th></tr>
<tr><th>rank</th><th>stamp</th><th>flag</th><th>text</th><th>owner</th><th>date</th><th>action</th></tr>
</thead>
<tbody id=tbody>
<tr id=row0><td>:idx</td><td>:ts</td><td>:flag</td><td style="overflow: hidden;">:text</td><td><a href=":gw_url/ipns/:owner">:alias</td><td>:date</td><td>:action</td></tr>
</tbody>
</table>
<br><input type=checkbox name=qmonpub> add root qm in log (i.e. publish as a <i>blockchain</i>)
<br>timestamp: <input name=ts value onmouseover="this.value=Date.now();">
<br>line: <input type=text name=record size=74>
<br><button id=submit>
<select name=op style="margin-right: 1rem;">
<option value=D >remove</option>
<option value=A selected>append</option>
</select><span onclick="submit(event)">submit</span>
</button>

<button id=publish onclick="publish(event)">publish</button>
<button id=update onclick="update(event)">update</button>
<progress id="bar" value="0" max="100">0%</progress><span id="per"></span>
<button id=reduce onclick="reduce(event)">reduce</button>
<br>url: <span id=url></span> (url of new log file on ipfs)
<br>root: <span id=root></span> (<a href=":gw_url/ipfs/:qmwebui/#/files/.../published/">/.../published/</a>)
<br>prev: <span id=prev></span> (previous version of root folder)
<br>remote: <span id=remote></span> (list of log file providers)
<hr>
<br>wlog:<br><textarea id=file cols=80 rows=25"></textarea>

</div>


<script>
var peerid;
const emptyd='QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn';
const qmgen='QmbFMke1KXqnYyBBWxB74N4c5SBnJMVAiMNRcGu6x1AwQH';
const webkey='QmY5irRjuwhhFvkY88ScnM7ow3DxvbhEi13mDAsUUVHRN4';
// ipfs name resolve QmY5irRjuwhhFvkY88ScnM7ow3DxvbhEi13mDAsUUVHRN4
const qmwebui='Qmb3cY3zFJ5isjJ5H9cP47Vfqa6pqNwypbuo2TiBGjUmLd';
const key='clef-secrete';
var label=document.getElementsByName('label')[0].value;
   let labelp = label.replace(/\s+/g,'-');
   document.getElementById('labelp').innerHTML = labelp;
let logf;
var innerTmpl;
var token;
var peerids;

main();
async function main() {
   // await Promise.resolve(promisedConfig); // just to wait for config !

   let maindiv = document.getElementsByTagName('div')[0];
   maindiv.innerHTML = maindiv.innerHTML.replace(/:gw_url/g,gw_url);
   maindiv.innerHTML = maindiv.innerHTML.replace(/:qmwebui/g,qmwebui);
   peerid = await promisedPeerId;
   if (typeof(peerid) == 'undefined') {
    /* alert('IPFS node NOT reachable') */
    /*
    */
    document.getElementsByClassName('modal')[0].style.display='block';
    document.getElementById('popup').style.display='block';
   }
   document.getElementById('peerid').innerHTML = `<a href=${gw_url}/ipns/${peerid}>${peerid}</a>`;
   console.log('main.peerid:',peerid);
   update_token( document.getElementsByName('label')[0].value);
   token = await get_token(nid);
   display_status('pending');
   peerids = await ipfsFindProvs(token);
   display_status('ok');
   display_provs(peerids);
   console.log('main.peerids',peerids);
}

function lineToDelete(event) {
const selection = event.target.value.substring(event.target.selectionStart, event.target.selectionEnd);
  console.log(`s√©lection : ${selection}`);
  document.getElementsByName('op')[0].value = 'D';
  document.getElementsByName("record")[0].value = selection;
  submit(event)
}


function change_token(ev) {
   label = ev.target.value.replace(/ /g,'-');
   update_token(label);
   display_table(logf);
}

async function update_token(label) {
   let [callee, caller] = functionNameJS(); // logInfo("message !")
   console.debug(callee+'.label:',label);
   let labelp = label.replace(/\s+/g,'-');
   document.getElementById('labelp').innerHTML = labelp;
   uri=`${key},urn:wwlog:${labelp}.txt`;
   nid= getNid(uri);
   logf = `/public/share/${nid}/${labelp}.txt`;
   document.getElementById('local').innerHTML = `<a target=_blank href=${gw_url}/ipns/${webkey}/#/files${logf}>${logf}</a>`;
   token = await get_token(nid);
   display_status('pending');
   peerids = await ipfsFindProvs(token);
   display_status('ok');
   display_provs(peerids);
   console.log('main.peerids',peerids);


}

async function get_token(str) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  token = await ipfsGetToken(str);
  console.debug(callee+'.token:',token);
  document.getElementById('token').innerHTML = token;
  return token
}

async function close_popup(ev) {
  let modal = document.getElementsByClassName('modal')[0];
  modal.style.display = 'none';
}


async function join(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let token = await ipfsAddToken(nid);
  console.debug(callee+'.token:',token);
  document.getElementById('token').innerHTML = `<a href=${gw_url}/ipfs/${token}>${token}</a>`;
}

async function display_provs(peerids) {
  let buf = '<ul>';
  for (peer of peerids) {
    buf += `<li><a target=_blank href=${gw_url}/ipns/${peer}/>${peer}</a></li>\n`
  }
  buf += "</ul>\n";
  document.getElementById('peerids').innerHTML = buf;
}

async function display_table(file) {
   let [callee, caller] = functionNameJS(); // logInfo("message !")
   let content = await getMFSFileContent(file);
   document.getElementById('file').value = content;
   let lines = content.split(/\r?\n/).slice(0,-1);
   let user = peerid;
   let records = [];
   for (let line of lines) {
     let matches = line.match(/^# user:(\w+)/);
     if (matches) {
        user = matches[1];
     } else if (line.match(/^\d+ /)) {
       record = mysplit(' ',line,3);
       if (record[1] == 'P') {
         user = record[2].match(/user:(\w+)/)[1];
       } 
       record[3] = user;
       records.push(record);
     }
   } 
   let selected = {};
   for (let record of records.sort(by_time) ) {
      let key = record[2];
      if (record[1] == 'A' || record[1] == 'P' ) {
         selected[key] = record;
      }
      if (record[1] == 'D') {
         delete selected[key];
      }
   }
   console.debug(callee+'.selected:',selected);
   let table = document.getElementById('tbody');
   // save template
   if (typeof(innerTmpl) == 'undefined') {
      innerTmpl = document.getElementById('row0').innerHTML;
   } else {
      console.log(callee+'.innerTmpl:',innerTmpl);
   }
   // clear table...
   clear_table();

   let skip ;
   let qmprev = emptyd;
   let qmcur = emptyd;
   let sorted_selected_keys = Object.keys(selected).sort(selected_by_timestamp)
   for (let key of sorted_selected_keys ) {

      let [timestamp,op,text,user] = selected[key];
      let textp = text.replace(user,alias(user));
      // Qm23456789012345678901234567890123456789012345
      // QmcfHufAK9ErQ9ZKJF7YX68KntYYBJngkGDoVKcZEJyRve
      let matches = textp.match(/Qm\w{44,}/);
      if (matches) {
         // console.debug(callee+'üêõ.matches:',matches)
         textp = textp.replace(matches[0],`<a href="${gw_url}/ipfs/${matches[0]}">${alias(matches[0])}</a>`);
      }
      let time = getTime(timestamp);
      let date = getDate(timestamp);
      let button = '<button onclick="delete_line(event)">delete</button>';
      let newrow = table.insertRow(-1); // insert in last position
      newrow.dataset['textRecord'] = text;
      // replace parameter's values w/i template :
      // format <tr id=row0><td>:idx</td><td>:ts</td><td>:flag</td><td>:text</td><td>:owner</td><td>:date</td><td>:action</td></tr>
      newrow.dataset['user'] = user;
      newrow.innerHTML = innerTmpl.replace(/:idx/,newrow.rowIndex-1);
      newrow.innerHTML = newrow.innerHTML.replace(/:ts/,time);
      newrow.innerHTML = newrow.innerHTML.replace(/\:flag/,op);
      newrow.innerHTML = newrow.innerHTML.replace(/\:text/,textp);
      newrow.innerHTML = newrow.innerHTML.replace(/\:owner/,user);
      newrow.innerHTML = newrow.innerHTML.replace(/\:alias/,alias(user));
      newrow.innerHTML = newrow.innerHTML.replace(/\:date/,date);
      newrow.innerHTML = newrow.innerHTML.replace(/\:action/,button);

      // compute previous ...
      // note: P records are deletable !
      if ( op == 'P' ) {
         lastpub = text
            let P = lastpub.split(/\s+/,3);
         qmprev = qmcur;
         qmcur = P[2];
         auth = P[0];
         newrow.dataset['qm'] = qmcur;
         /* console.debug(callee+'.auth:',auth);
            console.debug(callee+'.qmcur:',qmcur);
            console.debug(callee+'.qmprev:',qmprev);
          */
         if (auth == `user:${peerid}`) { skip = 1; }
      } else {
         skip = 0;
      }
      console.debug(callee+'.newrow:',newrow);
   }
   console.debug(callee+'.qmcur:last:',qmcur);
   console.debug(callee+'.auth:last:',auth);
   if (! skip) {
     qmprev = qmcur;
   }
   if (qmprev != emptyd) {
     document.getElementById('prev').innerHTML = `<a href=${gw_url}/ipfs/${qmprev}${logf}>${qmprev}</a>`;
   }

   function selected_by_timestamp(a,b) {
     return ((selected[a][0] - selected[b][0]) || compare(a,b));
   }
}

function delete_line(ev) {
  let [callee, caller] = functionNameJS();
  console.log(callee+'.ev.target:',ev.target)
  let gdparent = ev.target.parentNode.parentNode;
  console.log(callee+'.gdparent:',gdparent)
  let timestamp = Date.now();
  //let textp = gdparent.getElementsByTagName('td')[3].innerText; // textContent;
  let line = gdparent.dataset['textRecord'];
  console.log(callee+'.line:',line)
  return submit_op(timestamp,'D',line);
}

function alias(u) {
  return u.substring(0,2)+'--'+u.substr(-6);
}

function clear_table() {
     let [callee, caller] = functionNameJS();
     let e = document.getElementById('table');
     console.log(callee+'.template row:',e.rows[2]);
     for (i = e.rows.length-1; i > 1; i--) {
           e.deleteRow(i)
     }
     console.log(callee+'.nrow after delete:',e.rows.length)
}

async function display_file(file) {
   let [callee, caller] = functionNameJS(); // logInfo("message !")
   let content = await getMFSFileContent(file);
   document.getElementById('file').value = content;
}

async function display_log(file) {
   let [callee, caller] = functionNameJS(); // logInfo("message !")
   let content = await getMFSFileContent(file);
   let lines = content.split(/\r?\n/).slice(0,-1);
   let filtered = lines.filter( _ => { return _.match(/^[^#]/) });
   let records = filtered.map( _ => { return mysplit(' ',_,3); });

   var selected = {};
   for (record of records.sort(by_time)) {
      console.debug(callee+'.record:',record);
      if (record[1] == 'A' || record[1] == 'P' ) {
         selected[record[2]] = record;
      }
      if (record[1] == 'D') {
         delete selected[record[2]];
      }
   }
   console.debug(callee+'.records.sort(by_time):',records.sort(by_time));
   console.debug(callee+'.selected:',selected);

}

function by_time(a,b) {
  return ((a[0] - b[0]) || compare(a[1],b[1]));
}
function numerically(a,b) {
  return (a.split(' ',1) - b.split(' ',1)) || compare(a,b);
}

function mysplit(sep,str,limit) { // split a la perl !
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let a = str.split(sep);
  let last = a[limit-1];
  for (let i = limit; i < a.length; i++) {
    last += sep + a[i];
  }
  a[limit-1] = last;
  a = a.slice(0,limit); // end position excluded
  // console.debug(callee+'.a:after',a)
  return a
}

async function provs(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  // if (typeof(peerids) == 'undefined') {
    console.debug(callee+'.token:',token);
    display_status('pending');
    peerids = await ipfsFindProvs(token);
    display_status('ok');
  // }
  
}

function chop(s) {
  return s.slice(0,-1);
}

async function reduce(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let seen = {};
  let result = '';
  let content = await getMFSFileContent(logf);
      content = content.replace(/\r\n/g,"\n").slice(0,-1); // remove last \n
  let lines = content.split(/\n/);
  // console.debug(callee+'.lines:',lines);
  for (let line of lines) {
    if (typeof(seen[line]) == 'undefined') {
      result += line+ "\n";
      seen[line]++;
    }
  }
  console.debug(callee+'.result:',[{result}]);
  await mfsRemove(logf);
  await mfsCopy('QmbFMke1KXqnYyBBWxB74N4c5SBnJMVAiMNRcGu6x1AwQH',logf);
  let qmlogf = await ipfsLogAppend(logf,result);
  document.getElementById('url').innerHTML = `<a href="${gw_url}/ipfs/${qmlogf}">/ipfs/${qmlogf}</a>`
  display_table(logf);
  return qmlogf
}

function progress (percent) {
let bar = document.getElementById("bar");
let per = document.getElementById("per");
bar.value = percent;
per.innerHTML = percent + "%";
}

async function update(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  document.getElementById('update').disabled=true
  let qmlogf;
  let buf = '<ul>';
  progress (10)
  for (let peer of peerids) {
    console.log(callee+'.peer:',peer);
    if (peer == peerid) { continue }
    let ipath = await ipfsNameResolve(peer);
    if (typeof(ipath) != 'undefined') {
    console.log(callee+'.ipath:',ipath);
    let qpath = await ipfsResolve(`${ipath}${logf}`);
    if (typeof(qpath) != 'undefined') {
       console.debug(callee+'.qpath:',qpath);
       let log = await ipfsGetContentByHash(qpath);
       console.debug(callee+'.log:',log);
       qmlogf = await ipfsLogAppend(logf,log);
       console.debug(callee+'.qmlogf:',qmlogf);
       buf += `<li><a target=_blank href=${gw_url}${qpath}/>${ipath}${logf}</a> (${alias(peer)})</li>\n`;
       document.getElementById('remote').innerHTML = buf + "</ul>";
       display_table(logf);
    }
    }
  }
  buf += "</ul>\n";
  document.getElementById('update').disabled=false;
  document.getElementById('remote').innerHTML = buf;
  console.debug(callee+'.qmlogf:',qmlogf);
progress (100)
  return qmlogf;
}

async function publish(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
   document.getElementById('publish').disabled=true
   let qm = await publish_root();
   let qm_on_publish_flag = document.getElementsByName('qmonpub')[0].checked;
   if (qm_on_publish_flag) {
      display_file(logf);
      let tics = Date.now();
      let date = getDate();
      let time = getTime();
      // no header for publish events !
      let record = `${tics} P user:${peerid} published ${qm} on ${date} @ ${time}`;
      let hash = await ipfsLogAppend(logf,record+"\n");
      console.log(callee+'.hash:',hash);
      display_table(logf);
   }

   document.getElementById('root').innerHTML = `<a href="${gw_url}/ipfs/${qm}">${qm}</a> (published root folder)`
      document.getElementById('publish').disabled=false

}

async function submit_op(timestamp,op_cmd,line) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")

  let record = `${timestamp} ${op_cmd} ${line}`;
  //let buf = await getMFSFileContent(path);
  let date = getDate();
  let time = getTime();
  let header = `# user:${peerid} on ${date} @ ${time}\n`;
  let hash = await ipfsLogAppend(logf,header+record+"\n");
  console.log(callee+'.hash:',hash);
  document.getElementById('url').innerHTML = `<a href=${gw_url}/ipfs/${hash}>${logf}</a>`;
  display_table(logf);
  return hash;
}


function submit(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let timestamp = document.getElementsByName('ts')[0].value;
  // let delete_flag = document.getElementsByName('delete')[0].checked ? 'D' : 'A';
  let op_cmd = document.getElementsByName('op')[0].value;
  console.debug(callee+'.op_cmd:',op_cmd);
  let line = document.getElementsByName('record')[0].value;
  console.debug(callee+'.line:',line);
  return submit_op(timestamp,op_cmd,line);
}
 
function display_status(s) {
  let imgs = { 'pending':'img/spinner.png', 'ok':'img/check-mark.png' };
  document.getElementById('status').innerHTML=`<img alt=${s} src=${imgs[s]} height="24">`;
  if (s.match('pending')) {
     document.getElementById('update').disabled=true
  } else if (s.match('ok')) { 
     document.getElementById('update').disabled=false
  }
}
</script>

