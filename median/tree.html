<!DOCTYPE html>
<meta charset="utf8"/>
<script src=../js/config.js></script>

<script src=../js/essential.js></script>
<script src=../js/sha256.js></script>
<script src=../js/ipfs.js></script>
<script src=../js/functions.js></script>
<!--
  findprovs on editor_token
 
  load all texts under each nid keys

  /my/submission/complaints/title/a-specific-topic_history-nid.log
  /public/./submission/complaints/title/a-specific-topic_history-nid.log

-->
<style>i { color: grey; }</style>
<div class=content>
<h2>Median for a Label<span id=treename></span></h2>
peerid: <span id=peerid><i>:peerid</i></span>
<br>editor_token_nid: <span id=editor_token_nid><i>:editor_token_nid</i></span>
<br>tree_label: <input name=tree_label placeholder="tree-label" onchange="update_label(event)">
<br>tree_token_label: <span id=tree_token_label><i>:tree_token_label</i></span>
<br>tree_token_nid: <span id=tree_token_nid><i>:tree_token_nid</i></span>
<br>tree_token_hash: <span id=tree_token_hash><i>:tree_token_hash</i></span>
<br>tree_hash: <span id=tree_hash><i>:tree_hash</i></span> (published log after submit)
<br>root_hash: <span id=root_hash><i>:root_hash</i></span>
<br>webui: <a target=_blank name=webui href="webui:/#/files/public/logs/">/public/logs</a>
<br><button onclick="node_create(event);">create a node</button>
<br><button id=find-button onclick="find_peers(event);">find peers on DHT</button>
<br>discovery: search for token_hash: <span id=searched_token_hash><i>:searched_token_hash</i></span>
<br>providers <span id=peers_status></span>:
<div id=peerids></div>

<br>qmhash: <input name=qminput placeholder="node-hash" onchange="update_qmhash_value(event);" size=43>
<br>qmhash:
<select name=qmhash onchange="update_qmhash(event);">
<option value="typed">as above</option>
<option value="1">option 1</option>
<option value="2">option 2</option>
<option value="3">option 3</option>
</select>
<span id=tree_status></span>
<div id=node style="display:none;">
<hr width="60%">
<br>node's tree: <input name=label value="" placeholder="tree's label to attached the text" disabled>
<br>path: <input name=path value="/public/submission/proposal" placeholder="mutable path" required>*
<br>author: <input name=author value="anonymous" placeholder="author">
<br>stamp: <input name=ts value onmouseover="this.value=Date.now();" required>*
<br>node_nid: <input name=node_nid value=":node_nid" disabled>
<br>category: <input type=text name=category value='' placeholder="category" required>*
<br>subject: <input type=text name=subject value='' onchange="node_nid_update(event);" placeholder="subject">
<br>date: <input type=date name=date value='' placeholder="date">
<script>
 document.getElementsByName('date')[0].valueAsDate = new Date();
</script>
<br><textarea name=node_text rows=5 cols=80></textarea>
<br><button onclick="node_submit(event);">submit</button>
<button onclick="notify(event);">notify</button>
<button onclick="node_close(event);">close</button>
<hr width="60%">
</div>
<hr>
median: <span id=median><i>:median</i></span>
<br>nb pers: <span id=sn><i>:sn</i></span>
<br>score: <input type="number" name="score" min="0" max="20" value="12" onchange="update_value(event);">
<input type="range" name="value" min="0" max="20" onchange="display_score(event);" class="slider">
<br><button onclick="node_rank(event);">rank node</button>
<button onclick="dot_create(event);">create a dot</button>
<br>qmdot: <span id=qmdot><i>:qmdot</i></span>
<br>qmhash: <span id=qmhash><i>:qmhash</i></span>
</div>

<script>
const dbug = 1;
var forest = {};
const qmempty = 'QmbFMke1KXqnYyBBWxB74N4c5SBnJMVAiMNRcGu6x1AwQH';
const qmwebui='Qmb3cY3zFJ5isjJ5H9cP47Vfqa6pqNwypbuo2TiBGjUmLd';

var tree_label = 'fair Tree';
var tree_labelp = 'fair-tree';
var peerid;
var peerids;
var ipns_cache = {};

let webui_url = `${gw_url}/ipfs/${qmwebui}`;
let webui_element = document.getElementsByName('webui')[0];
    console.log('main.webui_url:',webui_url);
    webui_element.href = webui_element.href.replace('webui:',webui_url);

let score = document.getElementsByName('score')[0].value;

function display_score(ev) {
 let value = ev.target.value;
 document.getElementsByName('score')[0].value= value;
}
function update_value(ev) {
 let value = ev.target.value;
 document.getElementsByName('value')[0].value= value;
}


var sn=0;
var rank = [];
var tree = { id:'god' };


// TODO have a registry to obtain public's private-key
const PUBLICID = 'QmezgbyqFCEybpSxCtGNxfRD9uDxC53aNv5PfhB3fGUhJZ';
const editor_token_label = `I have submitted a proposal to ${shortqm(PUBLICID)}`;
const editor_token_nid = getNid(`uri:text:${editor_token_label}`);
document.getElementById('editor_token_nid').innerHTML=editor_token_nid;

var tree_token_nid;
var tree_token_label = editor_token_label + ' for ' + tree_label;
update_label({});

function update_label(ev) {
  let label = document.getElementsByName('tree_label')[0].value;
  if (typeof(label) != 'undefined' && label != '') {
    tree_label = label;
    tree_labelp = tree_label.toLowerCase().replace(/ +/g,'-');
    tree_token_label = editor_token_label + ' for ' + tree_label;
  }
  console.log('update_label.tree_labelp:', tree_labelp);
  tree_token_nid = getNid(`uri:tree:${tree_token_label}`);
  document.getElementById('tree_token_label').innerHTML=tree_token_label;
  document.getElementById('tree_token_nid').innerHTML=tree_token_nid;
  document.getElementsByName('label')[0].value = tree_label;

}

function update_qmhash_value(ev) {
  let qmselect = document.getElementsByName('qmhash')[0];
  let qmhash = ev.target.value;
  qmselect.options[0].value = qmhash;
  qmselect.options[0].text = `as above: ${shortqm(qmhash)}`;
  return qmhash
} 
function update_qmhash(ev) {
  let qmhash = document.getElementsByName('qmhash')[0].value;
  document.getElementById('qmhash').innerHTML = `<a target="_blank" href=${gw_url}/ipfs/${qmhash}>${qmhash}</a>`;
  return qmhash;
}


main();
async function main() {
  display_score({ target: document.getElementsByName('score')[0] });
  update_value({ target: document.getElementsByName('score')[0] });
  peerid = await promisedPeerId;
  document.getElementById('peerid').innerHTML = `<a href=${gw_url}/ipns/${peerid}>${peerid}</a>`;
}
</script>

<script>
function node_create(ev) {
  document.getElementById('node').style.display = ''; // to display it w/o 'blocking'
}
async function node_close(ev) {
  document.getElementById('node').style.display = 'none';
}
async function node_submit(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let subject = document.getElementsByName('subject')[0].value;
  let buf = `Subject: ${subject}\n\n`
      buf += document.getElementsByName('node_text')[0].value;
  // let qmhash = await ipfsGetHashByContent(buf);
  let qmhash = await ipfsPostHashByContent(buf);
  console.debug(callee+'.qmhash:',qmhash);
  document.getElementsByName('qmhash')[0].value = qmhash;
  document.getElementById('qmhash').innerHTML = qmhash;
  let tree_log_path = `/public/logs/${tree_labelp}.log`
  console.debug(callee+'.tree_log_path:',tree_log_path);
  tree_add_qm(tree_log_path,qmhash);

}

async function tree_add_qm(path,qm) {
  let ts = document.getElementsByName('ts')[0].value;
  if (ts == '') {
    ts = Date.now();
  }
  let author = document.getElementsByName('author')[0].value; 
  let subject = document.getElementsByName('subject')[0].value; 
  let category = document.getElementsByName('category')[0].value; 
  let node_path = document.getElementsByName('path')[0].value; 
  let subjectp = subject.replace(/ +/g,'-');
  record = `${ts}: ${qm} ${peerid} ${author}:${subjectp} ${node_path}/${category}\n`
  let qmtree = await ipfsLogAppend(path,record);
  document.getElementById('tree_hash').innerHTML = `<a href=${gw_url}/ipfs/${qmtree}>${qmtree}</a>`;

}
async function notify(ev) {
  document.getElementById('root_hash').innerHTML = '<img src="../img/spinner.gif" height="24">';
  let root_hash = await publish_root()
  document.getElementById('root_hash').innerHTML = `<a href=${gw_url}/ipfs/${root_hash}>${root_hash}</a>`;
  let published_token = await ipfsSetToken(tree_token_nid);
  document.getElementById('tree_token_hash').innerHTML = published_token;
}
async function node_rank(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let score = +(document.getElementsByName('score')[0].value);
  let qmhash = document.getElementsByName('qmhash')[0].value;
  // URN: Francois Colonna  (uniq name)
  // URI: Fancois + Paris 13 
  // URL: Paris 13
  let node_nid = getNid(`urn:ipfs:${qmhash}`);
  let ranker_token_label = `I have ranked a proposal on ${node_nid}`;
  let ranker_nid = getNid(`urn:text:${ranker_token_label}`);

  document.getElementsByName('node_nid')[0].value = node_nid;
  let node = { score:score, id:`n${sn}-${node_nid.substr(0,3)}`,sn:0, payload: qmhash, median:0,addr:0,level:0,
               sum : 0, d_order : 0, u_order : 0, r_order : rank[sn++],
               children : [], medians : [], parents : [] };
  console.debug(callee+'.node:',node);
  tree = node_insert(node,tree);
  document.getElementById('median').innerHTML = tree.median;
  document.getElementById('sn').innerHTML = tree.sn;
  console.debug(callee+'.tree:',tree);
}
function node_insert(node,tree) {
   let [callee, caller] = functionNameJS(); // logInfo("message !")

   console.debug(callee+'.info: node-insert: %s:%d',node.id,node.score);
   let root = tree;
   if (typeof(root.children) == 'undefined') { // empty tree
      node.sn = 1;
      node.addr = 0;
      node.medians = [node,node];
      node.median = 0.0 + node.score;
      node.parents = [];
      return node;
   }
   // start search at root:
   let pos = root; // tree current position
   let spot = undefined; // place where node is to be inserted;
   let medianm = root.medians[0];
   let medianp = root.medians[1];

   while (typeof(spot) == 'undefined') {
      let comp = compare_by_score(node,pos);
      console.debug(callee+'.comp:',`${node.id}:${node.score} <=> ${pos.id}:${pos.score} = ${comp}`);
      if (comp > 0) { // right insert
         if ( typeof(pos.children[1]) == 'undefined' ) {
            console.debug(callee+`.info: // attach node ${node.id} to tree (right branch)`);
            pos.children[1] = node;
            node.level = pos.level + 1;
            node.addr = get_addr(pos.addr,1); // direction=1 i.e. right
            spot = pos;
         } else { // no splot available at this level : go down the right branch
            pos = pos.children[1];
         }
         node.u_order = pos.u_order + 1;
      } else if (comp < 0) { // left insert 
         if ( typeof(pos.children[0]) == 'undefined' ) {
            console.debug(callee+`.info: // attach node ${node.id} to tree (left branch of ${pos.id})`);
            pos.children[0] = node;
            node.level = pos.level + 1;
            node.addr = get_addr(pos.addr,0); //direction=0 i.e left
            spot = pos;
         } else { // no spot available at this level : go down the left branch
            pos = pos.children[0];
         }
         node.d_order = pos.d_order + 1;
      } else { // comp = 0
         if ( typeof(pos.children[0]) == 'undefined' ) { // left branch prefered ...
            console.debug(callee+`.info: // attach node ${node.id} to tree (left branch of ${pos.id})`);
            pos.children[0] = node;
            node.level = pos.level + 1;
            node.addr = get_addr(pos.addr,0);
            comp = -1; // considering new node smaller than pos;
            spot = pos;
            console.debug(callee+".node inserted on the left side of %s:%d comp=%d\n",spot.id,spot.score,comp);
         } else if ( typeof(pos.children[1]) == 'undefined' ){ 
            console.debug(callee+`.info: // attach node ${node.id} to tree (right branch of ${pos.id})`);
            pos.children[1] = node;
            node.level = pos.level + 1;
            node.addr = get_addr(pos.addr,1);
            comp = +1; // considering new node bigger than pos;
            spot = pos;
            console.debug(callee+".node inserted on the right side of %s:%d comp=%d\n",spot.id,spot.score,comp);
         } else { // no spot available at this level : go down the any branch
            let dir = Math.random() > 0.5 ? 1 : 0; // /!\ random walk !
            console.debug(callee+".info: RANDOM bifurcation: %s !",dir?'right':'left');
            console.debug(callee+".info: continue down the %s branch of %s",(dir?'right':'left'),pos.id);
            comp = dir?1:-1;
            pos = pos.children[dir];
         }
      }
   } // while
   if (spot) {
      console.debug(callee+'.spot:',spot);
      node.parents = [...spot.parents,spot]; // update parents list ...
      console.debug(callee+".info: %s's parents: %s",node.id,node.parents.map( _ => { return _.id; }).join(','));
   }
   // update n
   node.sn = 1;
   console.debug(callee+'.node.parents: ',node.parents.map( _ => { return _.id; }))
   for (let pn of node.parents) { pn.sn = pn.sn + 1; }
   console.debug(callee+'.root.sn: %d (%d)',root.sn,root.id);

   // compare node w/ medians
   let comp0 = compare_by_score(node,medianm);
   let comp1 = compare_by_score(node,medianp);
   console.debug(callee+".info: median-comp0: %s:%d <=> %s:%d = %s",node.id,node.score,medianm.id,medianm.score,comp0);
   console.debug(callee+".info: median-comp1: %s:%d <=> %s:%d = %s",node.id,node.score,medianp.id,medianp.score,comp1);
   // update medians
   if (comp1 > 0) {
      console.debug(callee+".info: update(m+ < node) : %s:%d >= %s:%d",node.id,node.score,medianp.id,medianp.score);
      if (medianm.id != medianp.id) { // 2 medians : was even so now it's odd
         if(root.sn % 2 == 0) {
            console.error(callee+'.error: sn is even /w one median /!\\');
         } else {
            console.debug(callee+'.info: odd -> one median');
         }
         root.medians[0] = medianp; // insertion was on the right side !
         console.debug(callee+".update-medianm: %s:%d",root.medians[0].id,root.medians[0].score);
      } else { // even
         if (root.sn % 2) {
            console.error(callee+'.error: sn is odd /w two medians /!\\');
         } else {
            console.debug(callee+'.info: even -> two medians');
         }
         root.medians[0] = medianp;
         root.medians[1] = find_next(medianp);
         console.debug(callee+".update-medianm: %s:%d",root.medians[0].id,root.medians[0].score);
         console.debug(callee+".update-medianp: %s:%d",root.medians[1].id,root.medians[1].score);
      }
   } else if (comp0 < 0) {
      console.debug(callee+".info: update(node < m-) : %s:%d <= %s:%d",node.id,node.score,medianm.id,medianm.score);
      if (medianm.id != medianp.id) { // odd
         if (root.sn % 2 == 0) {
            console.error(callee+'.error: sn is even w/ one median /!\\');
         } else {
            console.debug(callee+'.odd : one median');
         }
         root.medians[1] = medianm;
         console.debug(callee+".update-medianp: %s:%d\n",root.medians[1].id,root.medians[1].score);
         // root.median = medianm.score;
         // console.debug(callee+".update-median: %.2f",root.median;
      } else { // even
         if (root.sn % 2) {
            console.error(callee+'.error: sn is odd w/ two median /!\\');
         } else {
            console.debug(callee+'.even : two medians');
         }
         root.medians[1] = medianm;
         root.medians[0] = find_prev(medianm);
         console.debug(callee+".update-medianm: %s:%d",root.medians[0].id,root.medians[0].score);
         console.debug(callee+".update-medianp: %s:%d",root.medians[1].id,root.medians[1].score);
      }
   } else if (0 < comp0 && comp1 < 0) {
      console.debug(callee+".info: update(m- < node < m+) : %s:%d < %s:%d < %s:%d",medianm.id,medianm.score,spot.id,spot.score,medianp.id,medianp.score);
      if (root.sn % 2 == 0) {
         console.error(callee+".error: n is even and score in between /!\\"); return 251;
      }
      root.medians[1] = node;
      root.medians[0] = node;
      console.debug(callee+".update-medianm: %s:%d",root.medians[0].id,root.medians[0].score);
      console.debug(callee+".update-medianp: %s:%d",root.medians[1].id,root.medians[1].score);

   } else if (comp0 == 0) {
      console.error(callee+".ERROR: comp0 == 0"); return 251;
   } else if (comp1 == 0) {
      console.error(callee+".ERROR: comp1 == 0"); return 251;
   } else {
      console.error(callee+".ERROR !"); return 251;
   }
   root.median = ( (+(root.medians[1].score)) + (+(root.medians[0].score)) ) / 2;
   console.debug(callee+".median-: %.2f",root.medians[0].score);
   console.debug(callee+".median+: %.2f",root.medians[1].score);
   console.debug(callee+".update-median: %.2f",root.median);

   console.debug(callee+".info: root.sn: %d",root.sn);
   // computes node's metrics
   node.sum = spot.sum + node.score;

   dot_create({});
   return root;
}

function get_addr(parent_addr,dir) {
 // parent_addr : parent address
 // dir : direction i.e. side (1:right or 0:left)
 let addr = parent_addr<<1 | dir;
 return addr;
}

// --------------------------------------------------------------
function find_next(pos) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  // pos: position
  // console.log("--- # %s: %s...\n",pos.id,Dump(parents));
  // all nodes in right subtree are bigger
  // next == smaller (redest) of bigger "right (blue)" branch ...
  // or first parent who has a "left (red) edge"
  let next = { "id":undefined };
  if (typeof(pos.children[1]) != 'undefined') { // next is in blue(right) branch
    next = pos.children[1];
    while (typeof(next.children[0]) != 'undefined') { // if a red(left) branch exists
      next = next.children[0];
    }
  } else { // next is in a parent subtree
     if (typeof(pos.parents) == 'undefined') { 
        return next;
     } 
     parents = pos.parents;
     if (dbug) {
        console.debug(callee+".dbug: find_next.pos: %s",pos.id);
        console.debug(callee+".dbug: find_next.parents: [%s]",parents.map( _ => { return _.id; }).join(','));
     }
     let parent = pos;
     // /!\ .reverse() is destructive
     for (let gdparent of ([...parents]).reverse()) {
        if (typeof(gdparent.children[0]) != 'undefined') {
           if (gdparent.children[0].id == parent.id) {
              next = gdparent; break;
           }
        }
        parent = gdparent;
     }
  }
  if (dbug) {
     if (typeof(next.id) != 'undefined') {
        console.debug(callee+".dbug: next-to: %s:%d is %s:%d",pos.id,pos.score,next.id,next.score);
     } else {
        console.debug(callee+".dbug: no-next-to: %s:%d (undef)",pos.id,pos.score);
     }
  }
  return next;
}
// --------------------------------------------------------------
function find_prev(pos) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  // pos = shift;
  if (dbug) { console.log(callee+".pos: %s\n",pos.id); }

  let prev = { "id":undefined };
  // lookup in the children tree
  if (typeof(pos.children[0]) != 'undefined') { // prev is in red(left) branch
     prev = pos.children[0];
     while (typeof(prev.children[1]) != 'undefined') { // if blue(right) children then descend blue side;
        prev = prev.children[1];
     }
  } else { // prev is in parent subtree
     if (typeof(pos.parents) == 'undefined') {
        return prev; // if no parent then prev = undefined !
     }    
     parents = pos.parents;
     if (dbug) {
        if (parents.length) {
           console.debug(callee+".dbug: find_prev.parents: [%s]",parents.map( _ => { return _.id; }).join(','));
        } else {
           console.debug(callee+".dbug: find_prev.parents: [] (%s no parents)",pos.id);
        }
     }
     parent = pos;
     // Careful: reverse is destructive -- it changes the original array.
     //let path = [...parents];
     //const path = (parents);
     for(let gdparent of [...parents].reverse()) {
        if (typeof(gdparent.children[1]) != 'undefined' && gdparent.children[1].id == parent.id) { // go up until blue
           if (dbug) { console.debug("gdparent: %s:%d (is blue)",gdparent.id,gdparent.score); }
           prev = gdparent; break;
        } else {
           if (dbug) { console.debug("gdparent: %s:%d (is red)",gdparent.id,gdparent.score); }
        }
        parent = gdparent;
     }
  }
  if (dbug) {
     if (typeof(prev.id) != 'undefined') {
        console.debug(callee+".dbug: prev-to: %s:%d is %s:%d",pos.id,pos.score,prev.id,prev.score);
     } else {
        console.debug(callee+".dbug: no-prev-to: %s:%d (undef)",pos.id,pos.score);
     }
  }
  return prev;
}
// --------------------------------------------------------------
function compare_by_score(a,b) {
    if (a.score > b.score) {
       order = 1;
    } else if (a.score < b.score) {
       order = -1;
    } else {
       order = addr_compare(a,b);
    }
    return order;
}

function addr_compare(a,b) {
  let fa = frac_addr(a.addr,a.level);
  let fb = frac_addr(b.addr,b.level);
  return compare (fa,fb);
}

function frac_addr(addr,level) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
 //console.debug(callee+'.addr:',addr);
 //console.debug(callee+'.level:',level);
 let frac = (addr + 0.5) / (2.0**level);
 //console.debug(callee+'.frac:',frac);
 return (addr + 0.5) / (2.0**level);
}

async function dot_create(ev) {
  let dbug = 0;
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let dot_buf = "digraph tree {\n";
      dot_buf += `"median-" -> "${tree.medians[0].id}"\n`;
      dot_buf += `"median+" -> "${tree.medians[1].id}"\n`;
  let list = [tree];
  while(list.length) {
     if (dbug) {
        console.debug(callee+'.while.list.length:',list.length)
        console.debug(callee+'.while.list: ',list.map( _ => { return _.id; }))
     }
    let node = list.shift();
    if (dbug) { console.debug(callee+'.while.node.id:',node.id); }
    let children = node.children || [];
    let faddr;
    if (typeof(node.id) != 'undefined') {
      let ismed = (tree.medians[0].id == node.id) ? 'm-' :
                  (tree.medians[1].id == node.id) ? 'm+' : '';
      faddr = frac_addr(node.addr,node.level);
      dot_buf += `"${node.id}" [shape="record" label="${node.id}|`+
                 `{{${node.d_order}|${node.r_order}|${node.u_order}|s=${node.sum}}|`+
                 `{${faddr}|score=${node.score}|${ismed}|sn=${node.sn}}}" ];\n`;
    }
    if (children.length) {
      if (dbug) { console.debug(callee+'.node.children:',children.map( _ => { return _.id; })); }
      let filtered_child = children.filter( _ => { return (typeof(_) != 'undefined');});
      if (dbug) { console.debug(callee+'.while.filtered_child: ',filtered_child.map( _ => { return _.id; })); }
      list.push(...filtered_child)
      if (dbug) { console.debug(callee+'.while.list.new: ',list.map( _ => { return _.id; })); }

      if (typeof(children[0]) != 'undefined') { // left child (red edge)
        dot_buf += ` "${node.id}" -> "${children[0].id}" [ color="red" ];\n`; 
      } else {
        if (dbug) { console.warn(callee+'.node.children[0]:',children[0]);}
      }
      if (typeof(children[1]) != 'undefined') { // right child (blue edge)
        dot_buf += ` "${node.id}" -> "${children[1].id}" [ color="blue" ];\n`; 
      } else {
        if (dbug) { console.warn(callee+'.node.children[1]:',children[1]); }
      }
    }
    if (typeof(node.id) != 'undefined') {
      if (dbug) { console.debug(callee+`.info: node: ${node.id} @${faddr} score=${node.score}`); }
    }
    
  }
  dot_buf += "}\n";
  let qmdot = await ipfsPostHashByContent(dot_buf);
  //document.getElementById('qmdot').innerHTML = `<a href=${gw_url}/ipfs/${qmdot}>${qmdot}</a>`;
  document.getElementById('qmdot').innerHTML = qmdot;
  return qmdot;
}

function node_nid_update(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let subject = ev.target.value;
  console.debug(callee+'.subject:',subject);
  var node_nid = getNid(`uri:tree:node:${subject}`);
  document.getElementsByName('node_nid')[0].value = node_nid;

}
async function find_peers(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  // if (typeof(peerids) == 'undefined') {
    // let hash = await ipfsAddTextContent(editor_token);
    var searched_token_hash = await ipfsGetToken(tree_token_nid);

    document.getElementById('searched_token_hash').innerHTML=shortqm(searched_token_hash);
    console.debug(callee+'.searched_token_hash:',searched_token_hash);
    display_status('pending');
    peerids = await ipfsFindProvs(searched_token_hash);
    display_status('ok');
    display_provs(peerids);
    document.getElementById('tree_status').innerHTML='<font color=orange>busy</font>';
    let tree = await get_tree(peerids)
    console.debug(callee+'.tree:',tree);
    let qmselect = document.getElementsByName('qmhash')[0];
    build_qmhash_select(qmselect, tree);
    document.getElementById('tree_status').innerHTML='<font color=green>OK</font>';
    
    
  // }
}


function build_qmhash_select(selid,tree) {
  for ( let i=selid.length-1; i > 0; i-- ) {
   selid.remove(i);
  }
  for (let record of tree) {
     let option = document.createElement('option');
     option.text = `${shortqm(record[1])} by ${record[3]}`;
     option.value = `${record[1]}`;
     selid.add(option);
  }
  return true;
}




async function get_tree(peers) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  console.log(callee+'.tree_labelp:',tree_labelp);
  let logs = '';
  for(let peer of peers) {
    let root_path = await ipfsNameResolve(peer);
    let tree_log_path = `${root_path}/public/logs/${tree_labelp}.log`;
    let buf = await ipfsGetContentByPath(tree_log_path);
    console.log(callee+'.buf:',buf);
    logs += buf;
  } 
  console.log(callee+'.logs:',logs);
  let data = load_sorted_log(logs);
  return data
}

function load_sorted_log(log) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let data = log.slice(0,-1).split('\n');
  console.log(callee+'.data:',data);
  let records = [];
  for (let rec of data) {
    let a_rec = rec.split(' ');
    a_rec[0] = a_rec[0].slice(0,-1);
    records.push(a_rec);
  }
  console.log(callee+'.records:',records);
  let selected = {};
  for (let rec of records.sort(by_stamp)) {
    let [stamp,qm,peer,nodeid,nodepath] = rec;
    console.log(callee+'.stamp: %s, nodeid: %s',stamp,nodeid);
    selected[nodeid] = rec
  }

  let sorted_records = Object.keys(selected).sort( (a,b) => {
    return compare(selected[a][0],selected[b][0]);
  }).map( k => { return selected[k]; });

  console.log(callee+'.sorted_records:',sorted_records);
  return sorted_records;

}

function by_stamp(a,b) {
 return compare(a[0],b[0]);
}

function display_status(s) {
  let imgs = { 'pending':'../img/spinner.gif', 'ok':'../img/check-mark.png' };
  document.getElementById('peers_status').innerHTML=`<img alt=${s} src=${imgs[s]} height="24">`;
  if (s.match('pending')) {
     document.getElementById('find-button').disabled=true
  } else if (s.match('ok')) { 
     document.getElementById('find-button').disabled=false
  }
}

async function display_provs(peerids) {
  let buf = '<ul>';
  for (peer of peerids) {
    buf += `<li><a target=_blank href=${gw_url}/ipns/${peer}/>${peer}</a></li>\n`
  }
  buf += "</ul>\n";
  document.getElementById('peerids').innerHTML = buf;
}
</script>
<!-- vim: syntax=javascript
-->
