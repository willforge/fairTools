<!DOCTYPE html>
<meta charset="utf8"/>
<script src=../js/config.js></script>

<script src=../js/essential.js></script>
<script src=../js/sha256.js></script>
<script src=../js/ipfs.js></script>
<script src=../js/functions.js></script>
<!--
  findprovs on editor_token
 
  load all texts under each nid keys

  /my/submission/complaints/title/a-specific-topic_history-nid.log
  /public/./submission/complaints/title/a-specific-topic_history-nid.log

-->
<style>i { color: grey; }</style>
<div class=content>
<h2>Tree <span id=treename></span></h2>
peerid: <span id=peerid><i>:peerid</i></span>
<br>editor_token_nid: <span id=editor_token_nid><i>:editor_token_nid</i></span>
<br>tree: <input name=treelabel placeholder="tree-label" onchange="update_label(event)">
<button onclick="node_create(event);">create a node</button>
<button onclick="dot_create(event);">create a dot</button>
<br>value: <span id=displayed_value></span>
<input type="range" name="value" min="0" max="20" value="12" onchange="display_value(event);" class="slider">
<br>score: <input type="integer" name="value" min="0" max="20" value="" onchange="node_create(event);" class="slider">
<br><span id=qmdot>:qmdot</span>
<div id=node style="display:;">
<br>path: <input name=path value="/public/submission/proposal" placeholder="mutable path">
<br>author: <input name=author placeholder="author">
<br>stamp: <input name=ts value onmouseover="this.value=Date.now();">
<br>node_nid: <input name=node_nid value=":node_nid" disabled>
<br>category: <input type=text name=category value='' placeholder="category">
<br>subject: <input type=text name=subject value='' onchange="node_nid_update(event);" placeholder="subject">
<br>date: <input type=date name=date value='' placeholder="date">
<script>
 document.getElementsByName('date')[0].valueAsDate = new Date();
</script>
<br><textarea name=node_text rows=5 cols=80></textarea>
<br><button onclick="submit(event);">submit</button>
<button onclick="notify(event);">notify</button>
<br><span id=qmhash>:qmhash</span>
</div>
<br>tree_token_label: <span id=tree_token_label><i>:tree_token_label</i></span>
<br>tree_token_nid: <span id=tree_token_nid><i>:tree_token_nid</i></span>
<br><button id=find-button onclick="find_peers(event);">find peers on DHT</button>
<br>discovery: search for token_hash: <span id=searched_token_hash><i>:searched_token_hash</i></span>
<br>providers <span id=status></span>:
<div id=peerids></div>
</div>

<script>
const dbug = 1;
var forest = {};
const qmempty = 'QmbFMke1KXqnYyBBWxB74N4c5SBnJMVAiMNRcGu6x1AwQH';
var tree_label = 'fairTree';
var peerid;
var peerids;

let val = document.getElementsByName('value')[0].value;
function display_value(ev) {
 let value = ev.target.value;
 document.getElementById('displayed_value').innerHTML= value;
}

var sn=0;
var rank = [];
var tree = { id:'god' };


// TODO have a registry to obtain public's private-key
const PUBLICID = 'QmezgbyqFCEybpSxCtGNxfRD9uDxC53aNv5PfhB3fGUhJZ';
const editor_token_label = `I have submitted a proposal to ${shortqm(PUBLICID)}`;
const editor_token_nid = getNid(`uri:text:${editor_token_label}`);
document.getElementById('editor_token_nid').innerHTML=editor_token_nid;

var tree_token_label = editor_token_label + ' for ' + tree_label;
var tree_token_nid = getNid(`uri:tree:${tree_token_label}`);
document.getElementById('tree_token_label').innerHTML=tree_token_label;
document.getElementById('tree_token_nid').innerHTML=tree_token_nid;


main();
async function main() {
  display_value({ target: document.getElementsByName('value')[0] });
  peerid = await promisedPeerId;
  document.getElementById('peerid').innerHTML = `<a href=${gw_url}/ipns/${peerid}>${peerid}</a>`;
}
</script>

<script>
async function node_create(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let val = +(document.getElementsByName('value')[0].value);
  let buf = document.getElementsByName('node_text')[0].value;
  // let qmhash = await ipfsGetHashByContent(buf);
  let qmhash = await ipfsPostHashByContent(buf);
  console.debug(callee+'.qmhash:',qmhash);
  document.getElementById('qmhash').innerHTML = qmhash;
  let node_nid = getNid(`uri:ipfs:${qmhash}`);
  document.getElementsByName('node_nid')[0].value = node_nid;
  let node = { val:val, id:`n${sn}-${node_nid.substr(0,3)}`,sn:0, payload: qmhash, median:0,addr:0,level:0,
               sum : 0, d_order : 0, u_order : 0, r_order : rank[sn++],
               children : [], medians : [], parents : [] };
  console.debug(callee+'.node:',node);
  tree = node_insert(node,tree);
}
function node_insert(node,tree) {
   let [callee, caller] = functionNameJS(); // logInfo("message !")

   console.debug(callee+'.info: node-insert: %s:%d',node.id,node.val);
   let root = tree;
   if (typeof(root.children) == 'undefined') { // empty tree
      node.sn = 1;
      node.addr = 0;
      node.medians = [node,node];
      node.median = 0.0 + node.val;
      node.parents = [];
      return node;
   }
   // start search at root:
   let pos = root; // tree current position
   let spot = undefined; // place where node is to be inserted;
   let medianm = root.medians[0];
   let medianp = root.medians[1];

   while (typeof(spot) == 'undefined') {
      let comp = compare_by_val(node,pos);
      console.debug(callee+'.comp:',`${node.id}:${node.val} <=> ${pos.id}:${pos.val} = ${comp}`);
      if (comp > 0) { // right insert
         if ( typeof(pos.children[1]) == 'undefined' ) {
            console.debug(callee+`.info: // attach node ${node.id} to tree (right branch)`);
            pos.children[1] = node;
            node.level = pos.level + 1;
            node.addr = get_addr(pos.addr,1); // direction=1 i.e. right
            spot = pos;
         } else { // no splot available at this level : go down the right branch
            pos = pos.children[1];
         }
         node.u_order = pos.u_order + 1;
      } else if (comp < 0) { // left insert 
         if ( typeof(pos.children[0]) == 'undefined' ) {
            console.debug(callee+`.info: // attach node ${node.id} to tree (left branch of ${pos.id})`);
            pos.children[0] = node;
            node.level = pos.level + 1;
            node.addr = get_addr(pos.addr,0); //direction=0 i.e left
            spot = pos;
         } else { // no spot available at this level : go down the left branch
            pos = pos.children[0];
         }
         node.d_order = pos.d_order + 1;
      } else { // comp = 0
         if ( typeof(pos.children[0]) == 'undefined' ) { // left branch prefered ...
            console.debug(callee+`.info: // attach node ${node.id} to tree (left branch of ${pos.id})`);
            pos.children[0] = node;
            node.level = pos.level + 1;
            node.addr = get_addr(pos.addr,0);
            comp = -1; // considering new node smaller than pos;
            spot = pos;
            console.debug(callee+".node inserted on the left side of %s:%d comp=%d\n",spot.id,spot.val,comp);
         } else if ( typeof(pos.children[1]) == 'undefined' ){ 
            console.debug(callee+`.info: // attach node ${node.id} to tree (right branch of ${pos.id})`);
            pos.children[1] = node;
            node.level = pos.level + 1;
            node.addr = get_addr(pos.addr,1);
            comp = +1; // considering new node bigger than pos;
            spot = pos;
            console.debug(callee+".node inserted on the right side of %s:%d comp=%d\n",spot.id,spot.val,comp);
         } else { // no spot available at this level : go down the any branch
            let dir = Math.random() > 0.5 ? 1 : 0; // /!\ random walk !
            console.debug(callee+".info: RANDOM bifurcation: %s !",dir?'right':'left');
            console.debug(callee+".info: continue down the %s branch of %s",(dir?'right':'left'),pos.id);
            comp = dir?1:-1;
            pos = pos.children[dir];
         }
      }
   } // while
   if (spot) {
      console.debug(callee+'.spot:',spot);
      node.parents = [...spot.parents,spot]; // update parents list ...
      console.debug(callee+".info: %s's parents: %s",node.id,node.parents.map( _ => { return _.id; }).join(','));
   }
   // update n
   node.sn = 1;
   console.debug(callee+'.node.parents: ',node.parents.map( _ => { return _.id; }))
   for (let pn of node.parents) { pn.sn = pn.sn + 1; }
   console.debug(callee+'.root.sn: %d (%d)',root.sn,root.id);

   // compare node w/ medians
   let comp0 = compare_by_val(node,medianm);
   let comp1 = compare_by_val(node,medianp);
   console.debug(callee+".info: median-comp0: %s:%d <=> %s:%d = %s",node.id,node.val,medianm.id,medianm.val,comp0);
   console.debug(callee+".info: median-comp1: %s:%d <=> %s:%d = %s",node.id,node.val,medianp.id,medianp.val,comp1);
   // update medians
   if (comp1 > 0) {
      console.debug(callee+".info: update(m+ < node) : %s:%d >= %s:%d",node.id,node.val,medianp.id,medianp.val);
      if (medianm.id != medianp.id) { // 2 medians : was even so now it's odd
         if(root.sn % 2 == 0) {
            console.error(callee+'.error: sn is even /w one median /!\\');
         } else {
            console.debug(callee+'.info: odd -> one median');
         }
         root.medians[0] = medianp; // insertion was on the right side !
         console.debug(callee+".update-medianm: %s:%d",root.medians[0].id,root.medians[0].val);
      } else { // even
         if (root.sn % 2) {
            console.error(callee+'.error: sn is odd /w two medians /!\\');
         } else {
            console.debug(callee+'.info: even -> two medians');
         }
         root.medians[0] = medianp;
         root.medians[1] = find_next(medianp);
         console.debug(callee+".update-medianm: %s:%d",root.medians[0].id,root.medians[0].val);
         console.debug(callee+".update-medianp: %s:%d",root.medians[1].id,root.medians[1].val);
      }
   } else if (comp0 < 0) {
      console.debug(callee+".info: update(node < m-) : %s:%d <= %s:%d",node.id,node.val,medianm.id,medianm.val);
      if (medianm.id != medianp.id) { // odd
         if (root.sn % 2 == 0) {
            console.error(callee+'.error: sn is even w/ one median /!\\');
         } else {
            console.debug(callee+'.odd : one median');
         }
         root.medians[1] = medianm;
         console.debug(callee+".update-medianp: %s:%d\n",root.medians[1].id,root.medians[1].val);
         // root.median = medianm.val;
         // console.debug(callee+".update-median: %.2f",root.median;
      } else { // even
         if (root.sn % 2) {
            console.error(callee+'.error: sn is odd w/ two median /!\\');
         } else {
            console.debug(callee+'.even : two medians');
         }
         root.medians[1] = medianm;
         root.medians[0] = find_prev(medianm);
         console.debug(callee+".update-medianm: %s:%d",root.medians[0].id,root.medians[0].val);
         console.debug(callee+".update-medianp: %s:%d",root.medians[1].id,root.medians[1].val);
      }
   } else if (0 < comp0 && comp1 < 0) {
      console.debug(callee+".info: update(m- < node < m+) : %s:%d < %s:%d < %s:%d",medianm.id,medianm.val,spot.id,spot.val,medianp.id,medianp.val);
      if (root.sn % 2 == 0) {
         console.error(callee+".error: n is even an val in between /!\\"); return 251;
      }
      root.medians[1] = node;
      root.medians[0] = node;
      console.debug(callee+".update-medianm: %s:%d",root.medians[0].id,root.medians[0].val);
      console.debug(callee+".update-medianp: %s:%d",root.medians[1].id,root.medians[1].val);

   } else if (comp0 == 0) {
      console.error(callee+".ERROR: comp0 == 0"); return 251;
   } else if (comp1 == 0) {
      console.error(callee+".ERROR: comp1 == 0"); return 251;
   } else {
      console.error(callee+".ERROR !"); return 251;
   }
   root.median = ( (+(root.medians[1].val)) + (+(root.medians[0].val)) ) / 2;
   console.debug(callee+".median-: %.2f",root.medians[0].val);
   console.debug(callee+".median+: %.2f",root.medians[1].val);
   console.debug(callee+".update-median: %.2f",root.median);

   console.debug(callee+".info: root.sn: %d",root.sn);
   // computes node's metrics
   node.sum = spot.sum + node.val;

   dot_create({});
   return root;
}

function get_addr(parent_addr,dir) {
 // parent_addr : parent address
 // dir : direction i.e. side (1:right or 0:left)
 let addr = parent_addr<<1 | dir;
 return addr;
}

// --------------------------------------------------------------
function find_next(pos) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  // pos: position
  // console.log("--- # %s: %s...\n",pos.id,Dump(parents));
  // all nodes in right subtree are bigger
  // next == smaller (redest) of bigger "right (blue)" branch ...
  // or first parent who has a "left (red) edge"
  let next = { "id":undefined };
  if (typeof(pos.children[1]) != 'undefined') { // next is in blue(right) branch
    next = pos.children[1];
    while (typeof(next.children[0]) != 'undefined') { // if a red(left) branch exists
      next = next.children[0];
    }
  } else { // next is in a parent subtree
     if (typeof(pos.parents) == 'undefined') { 
        return next;
     } 
     parents = pos.parents;
     if (dbug) {
        console.debug(callee+".dbug: find_next.pos: %s",pos.id);
        console.debug(callee+".dbug: find_next.parents: [%s]",parents.map( _ => { return _.id; }).join(','));
     }
     let parent = pos;
     let path = [...parents];
     for (let gdparent of path.reverse()) {
        if (typeof(gdparent.children[0]) != 'undefined') {
           if (gdparent.children[0].id == parent.id) {
              next = gdparent; break;
           }
        }
        parent = gdparent;
     }
  }
  if (dbug) {
     if (typeof(next.id) != 'undefined') {
        console.debug(callee+".dbug: next-to: %s:%d is %s:%d",pos.id,pos.val,next.id,next.val);
     } else {
        console.debug(callee+".dbug: no-next-to: %s:%d (undef)",pos.id,pos.val);
     }
  }
  return next;
}
// --------------------------------------------------------------
function find_prev(pos) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  // pos = shift;
  if (dbug) { console.log(callee+".pos: %s\n",pos.id); }

  let prev = { "id":undefined };
  // lookup in the children tree
  if (typeof(pos.children[0]) != 'undefined') { // prev is in red(left) branch
     prev = pos.children[0];
     while (typeof(prev.children[1]) != 'undefined') { // if blue(right) children then descend blue side;
        prev = prev.children[1];
     }
  } else { // prev is in parent subtree
     if (typeof(pos.parents) == 'undefined') {
        return prev; // if no parent then prev = undefined !
     }    
     parents = pos.parents;
     if (dbug) {
        if (parents.length) {
           console.debug(callee+".dbug: find_prev.parents: [%s]",parents.map( _ => { return _.id; }).join(','));
        } else {
           console.debug(callee+".dbug: find_prev.parents: [] (%s no parents)",pos.id);
        }
     }
     parent = pos;
     // Careful: reverse is destructive -- it changes the original array.
     let path = [...parents];
     //const path = (parents);
     for(let gdparent of path.reverse()) {
        if (typeof(gdparent.children[1]) != 'undefined' && gdparent.children[1].id == parent.id) { // go up until blue
           if (dbug) { console.debug("gdparent: %s:%d (is blue)",gdparent.id,gdparent.val); }
           prev = gdparent; break;
        } else {
           if (dbug) { console.debug("gdparent: %s:%d (is red)",gdparent.id,gdparent.val); }
        }
        parent = gdparent;
     }
  }
  if (dbug) {
     if (typeof(prev.id) != 'undefined') {
        console.debug(callee+".dbug: prev-to: %s:%d is %s:%d",pos.id,pos.val,prev.id,prev.val);
     } else {
        console.debug(callee+".dbug: no-prev-to: %s:%d (undef)",pos.id,pos.val);
     }
  }
  return prev;
}
// --------------------------------------------------------------
function compare_by_val(a,b) {
    if (a.val > b.val) {
       order = 1;
    } else if (a.val < b.val) {
       order = -1;
    } else {
       order = addr_compare(a,b);
    }
    return order;
}

function addr_compare(a,b) {
  let fa = frac_addr(a.addr,a.level);
  let fb = frac_addr(b.addr,b.level);
  return compare (fa,fb);
}

function frac_addr(addr,level) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
 //console.debug(callee+'.addr:',addr);
 //console.debug(callee+'.level:',level);
 let frac = (addr + 0.5) / (2.0**level);
 //console.debug(callee+'.frac:',frac);
 return (addr + 0.5) / (2.0**level);
}

async function dot_create(ev) {
  let dbug = 0;
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let dot_buf = "digraph tree {\n";
      dot_buf += `"median-" -> "${tree.medians[0].id}"\n`;
      dot_buf += `"median+" -> "${tree.medians[1].id}"\n`;
  let list = [tree];
  while(list.length) {
     if (dbug) {
        console.debug(callee+'.while.list.length:',list.length)
        console.debug(callee+'.while.list: ',list.map( _ => { return _.id; }))
     }
    let node = list.shift();
    if (dbug) { console.debug(callee+'.while.node.id:',node.id); }
    let children = node.children || [];
    let faddr;
    if (typeof(node.id) != 'undefined') {
      let ismed = (tree.medians[0].id == node.id) ? 'm-' :
                  (tree.medians[1].id == node.id) ? 'm+' : '';
      faddr = frac_addr(node.addr,node.level);
      dot_buf += `"${node.id}" [shape="record" label="${node.id}|`+
                 `{{${node.d_order}|${node.r_order}|${node.u_order}|s=${node.sum}}|`+
                 `{${faddr}|val=${node.val}|${ismed}|sn=${node.sn}}}" ];\n`;
    }
    if (children.length) {
      if (dbug) { console.debug(callee+'.node.children:',children.map( _ => { return _.id; })); }
      let filtered_child = children.filter( _ => { return (typeof(_) != 'undefined');});
      if (dbug) { console.debug(callee+'.while.filtered_child: ',filtered_child.map( _ => { return _.id; })); }
      list.push(...filtered_child)
      if (dbug) { console.debug(callee+'.while.list.new: ',list.map( _ => { return _.id; })); }

      if (typeof(children[0]) != 'undefined') { // left child (red edge)
        dot_buf += ` "${node.id}" -> "${children[0].id}" [ color="red" ];\n`; 
      } else {
        if (dbug) { console.warn(callee+'.node.children[0]:',children[0]);}
      }
      if (typeof(children[1]) != 'undefined') { // right child (blue edge)
        dot_buf += ` "${node.id}" -> "${children[1].id}" [ color="blue" ];\n`; 
      } else {
        if (dbug) { console.warn(callee+'.node.children[1]:',children[1]); }
      }
    }
    if (typeof(node.id) != 'undefined') {
      if (dbug) { console.debug(callee+`.info: node: ${node.id} @${faddr} val=${node.val}`); }
    }
    
  }
  dot_buf += "}\n";
  let qmdot = await ipfsPostHashByContent(dot_buf);
  //document.getElementById('qmdot').innerHTML = `<a href=${gw_url}/ipfs/${qmdot}>${qmdot}</a>`;
  document.getElementById('qmdot').innerHTML = qmdot;
  return qmdot;
}

function node_nid_update(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let subject = ev.target.value;
  console.debug(callee+'.subject:',subject);
  var node_nid = getNid(`uri:tree:node:${subject}`);
  document.getElementsByName('node_nid')[0].value = node_nid;

}
async function find_peers(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  // if (typeof(peerids) == 'undefined') {
    // let hash = await ipfsAddTextContent(editor_token);
    var searched_token_hash = await ipfsGetToken(tree_token_nid);

    document.getElementById('searched_token_hash').innerHTML=shortqm(searched_token_hash);
    console.debug(callee+'.searched_token_hash:',searched_token_hash);
    display_status('pending');
    peerids = await ipfsFindProvs(searched_token_hash);
    display_status('ok');
    display_provs(peerids);
    
  // }
}

function display_status(s) {
  let imgs = { 'pending':'../img/spinner.gif', 'ok':'../img/check-mark.png' };
  document.getElementById('status').innerHTML=`<img alt=${s} src=${imgs[s]} height="24">`;
  if (s.match('pending')) {
     document.getElementById('find-button').disabled=true
  } else if (s.match('ok')) { 
     document.getElementById('find-button').disabled=false
  }
}

async function display_provs(peerids) {
  let buf = '<ul>';
  for (peer of peerids) {
    buf += `<li><a target=_blank href=${gw_url}/ipns/${peer}/>${peer}</a></li>\n`
  }
  buf += "</ul>\n";
  document.getElementById('peerids').innerHTML = buf;
}
</script>
