<!DOCTYPE html>
<meta charset="utf8"/>
<script src=../js/config.js></script>

<script src=../js/essential.js></script>
<script src=../js/sha256.js></script>
<script src=../js/ipfs.js></script>
<script src=../js/functions.js></script>
<!--
  findprovs on editor_token
 
  load all texts under each nid keys

  /my/submission/complaints/title/a-specific-topic_history-nid.log
  /public/./submission/complaints/title/a-specific-topic_history-nid.log

-->
<style>i { color: grey; }</style>
<div class=content>
<h2>Tree <span id=treename></span></h2>
peerid: <span id=peerid><i>:peerid</i></span>
<br>editor_token_nid: <span id=editor_token_nid><i>:editor_token_nid</i></span>
<br>tree: <input name=treelabel placeholder="tree-label" onchange="update_label(event)">
<button onclick="create_node(event);">create a node</button>
<br>value: <span id=displayed_value></span>
<input type="range" name="value" min="0" max="20" value="12" onchange="display_value(event);" class="slider">
<div id=node style="display:;">
<br>path: <input name=path value="/public/submission/proposal" placeholder="mutable path">
<br>author: <input name=author placeholder="author">
<br>stamp: <input name=ts value onmouseover="this.value=Date.now();">
<br>node_id: <input name=node_nid value=":node_nid" disabled>
<br>category: <input type=text name=category value='' placeholder="category">
<br>subject: <input type=text name=subject value='' onchange="update_node_nid(event);" placeholder="subject">
<br>date: <input type=date name=date value='' placeholder="date">
<script>
 document.getElementsByName('date')[0].valueAsDate = new Date();
</script>
<br><textarea name=node_text rows=5 cols=80></textarea>
<br><button onclick="submit(event);">submit</button>
<button onclick="notify(event);">notify</button>
<br><span id=qmhash>:qmhash</span>
</div>
<br>tree_token_label: <span id=tree_token_label><i>:tree_token_label</i></span>
<br>tree_token_nid: <span id=tree_token_nid><i>:tree_token_nid</i></span>
<br><button id=find-button onclick="find_peers(event);">find peers on DHT</button>
<br>discovery: search for token_hash: <span id=searched_token_hash><i>:searched_token_hash</i></span>
<br>providers <span id=status></span>:
<div id=peerids></div>
</div>

<script>
const qmempty = 'QmbFMke1KXqnYyBBWxB74N4c5SBnJMVAiMNRcGu6x1AwQH';
var tree_label = 'fairTree';
var peerid;
var peerids;

let val = document.getElementsByName('value')[0].value;
function display_value(ev) {
 let value = ev.target.value;
 document.getElementById('displayed_value').innerHTML= value;
}

var sn=0;
var rank = [];
var tree = { id:'god' };


// TODO have a registry to obtain public's private-key
const PUBLICID = 'QmezgbyqFCEybpSxCtGNxfRD9uDxC53aNv5PfhB3fGUhJZ';
const editor_token_label = `I have submitted a proposal to ${shortqm(PUBLICID)}`;
const editor_token_nid = getNid(`uri:text:${editor_token_label}`);
document.getElementById('editor_token_nid').innerHTML=editor_token_nid;

var tree_token_label = editor_token_label + ' for ' + tree_label;
var tree_token_nid = getNid(`uri:tree:${tree_token_label}`);
document.getElementById('tree_token_label').innerHTML=tree_token_label;
document.getElementById('tree_token_nid').innerHTML=tree_token_nid;


main();
async function main() {
  display_value({ target: document.getElementsByName('value')[0] });
  peerid = await promisedPeerId;
  document.getElementById('peerid').innerHTML = `<a href=${gw_url}/ipns/${peerid}>${peerid}</a>`;
}
</script>

<script>
async function create_node(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let val = document.getElementsByName('value')[0].value;
  let buf = document.getElementsByName('node_text')[0].value;
  // let qmhash = await ipfsGetHashByContent(buf);
  let qmhash = await ipfsPostHashByContent(buf);
  console.debug(callee+'.qmhash:',qmhash);
  document.getElementById('qmhash').innerHTML = qmhash;
  let node = { val:val, id:'root',n:0, payload: qmempty, median:0,addr:0,level:0,
               sum : 0, d_order : 0, u_order : 0, r_order : rank[sn++],
               children : [], medians : [], parents : [] };
  tree = insert_node(node,tree);
}
function insert_node(node,tree) {

 let root = tree;
 if (typeof(root.children) == 'undefined') { // empty tree
   node.sn = 1;
   node.medians = [node,node];
   node.median = node[val];
   node.parents = [];
   return node;
 }
 let pos = root; // tree current position
 let spot = undefined; // place where node is to be inserted;
 let medianm = root.medians[0];
 let medianp = root.medians[1];

 while (typeof(spot) == 'undefined') {
   let comp = compare(node,pos);
   console.debug(callee+'.comp:',`${node.id} <=> ${pos.id} = ${comp}`);
   if (comp > 0) { // right insert
     if ( typeof(pos.children[1]) == 'undefined' ) {
       // attach node to tree (right branch)
       pos.children[1] = node;
       node.level = pos.level + 1;
       node.addr = get_addr(pos.addr,1); // direction=1 i.e. right
       spot = pos;
     } else { // no splot available at this level : go down the right branch
       pos = pos.children[1];
     }
     node.u_order = pos.u_order + 1;
   } else if (comp < 0) { // left insert 
      if ( typeof(pos.children[0]) == 'undefined' ) {
        // attach node to tree (left branch)
        pos.children[0] = node;
        node.level = pos.level + 1;
        node.addr = get_addr(pos.addr,0); //direction=0 i.e left
        spot = pos;
      } else { // no spot available at this level : go down the left branch
        pos = pos.children[0];
      }
      node.d_order = pos.d_order + 1;
   } else { // comp = 0
     if ( typeof(pos.children[0]) == 'undefined' ) { // left branch prefered ...
       // attach node to tree (left branch)
       pos.children[0] = node;
       node.level = pos.level + 1;
       node.addr = get_addr(pos.addr,0);
       comp = -1; // considering new node smaller than pos;
       spot = pos;
       console.debug(callee+".node inserted on the left side of %s:%d comp=%d\n",spot.id,spot.val,comp);
     } else if ( typeof(pos.children[1]) == 'undefined' ){ 
       // attach node to tree (right branch);
       pos.children[1] = node;
       node.level = pos.level + 1;
       node.addr = get_addr(pos.addr,1);
       comp = +1; // considering new node bigger than pos;
       spot = pos;
       console.debug(callee+".node inserted on the right side of %s:%d comp=%d\n",spot.id,spot.val,comp);
     } else { // no spot available at this level : go down the any branch
       let dir = Math.random() > 0.5 ? 1 : 0; // /!\ random walk !
       console.debug(callee+".info: RANDOM bifurcation: %s !",dir?'right':'left');
       console.debug(callee+".info: continue down the %s branch of %s",(dir?'right':'left'),pos.id);
       comp = dir?1:-1;
       pos = pos.children[dir];
     }
   }
 } // while
 if (spot) {
   node.parents = node.parents.push(spot); // update parents list ...
   console.debug(callee+".info: %s's parents: %s",node.id,node.parents.map( _ => { _.id }).join(','));
 }
 // update n
 node.sn = 1;
 for (let pn of node.parents) {
   pn.sn = pn.sn + 1;
 }
 // compare node w/ medians
 let comp0 = compare(node,medianm);
 let comp1 = compare(node,medianp);
 console.debug(callee+".info: median-comp0: %s <=> %s:%d = %s",node.id,medianm.id,medianm.val,comp0);
 console.debug(callee+".info: median-comp1: %s <=> %s:%d = %s",node.id,medianp.id,medianp.val,comp1);

}
function compare(a,b) {
  return a > b ? -1 : 1; // TO BE CHANGED i.e. syntax test
}
function get_addr(addr,dir) {
 return addr+dir; // TO BE CHANGED i.e. syntax test

}
function update_node_nid(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  let subject = ev.target.value;
  console.debug(callee+'.subject:',subject);
  var node_nid = getNid(`uri:tree:node:${subject}`);
  document.getElementsByName('node_nid')[0].value = node_nid;

}
async function find_peers(ev) {
  let [callee, caller] = functionNameJS(); // logInfo("message !")
  // if (typeof(peerids) == 'undefined') {
    // let hash = await ipfsAddTextContent(editor_token);
    var searched_token_hash = await ipfsGetToken(tree_token_nid);

    document.getElementById('searched_token_hash').innerHTML=shortqm(searched_token_hash);
    console.debug(callee+'.searched_token_hash:',searched_token_hash);
    display_status('pending');
    peerids = await ipfsFindProvs(searched_token_hash);
    display_status('ok');
    display_provs(peerids);
    
  // }
}

function display_status(s) {
  let imgs = { 'pending':'../img/spinner.gif', 'ok':'../img/check-mark.png' };
  document.getElementById('status').innerHTML=`<img alt=${s} src=${imgs[s]} height="24">`;
  if (s.match('pending')) {
     document.getElementById('find-button').disabled=true
  } else if (s.match('ok')) { 
     document.getElementById('find-button').disabled=false
  }
}

async function display_provs(peerids) {
  let buf = '<ul>';
  for (peer of peerids) {
    buf += `<li><a target=_blank href=${gw_url}/ipns/${peer}/>${peer}</a></li>\n`
  }
  buf += "</ul>\n";
  document.getElementById('peerids').innerHTML = buf;
}
</script>
